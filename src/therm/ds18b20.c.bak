#include "ds18b20.h"

GPIO_InitTypeDef GPIO_InitStructure;
	
void ds18b20_io_init(void){	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 ; 								
	GPIO_Init(DS18B20_PORT, &GPIO_InitStructure);
}

void ds18b20_change_mode(u16 pin, u8 mode){
	if(mode==DS18B20_IN){
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
		GPIO_InitStructure.GPIO_Pin = pin;
		GPIO_Init(DS18B20_PORT, &GPIO_InitStructure);
	}
	else {		
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
		GPIO_InitStructure.GPIO_Pin = pin;
		GPIO_Init(DS18B20_PORT, &GPIO_InitStructure);
	}
}

void ds18b20_init(u16 pin){
	ds18b20_change_mode(pin, DS18B20_OUT);
	GPIO_WriteBit(DS18B20_PORT, pin, 0);
	_delay_us(500);
	GPIO_WriteBit(DS18B20_PORT, pin, 1);
	ds18b20_change_mode(pin, DS18B20_IN);
	while(GPIO_ReadInputDataBit(DS18B20_PORT, pin));
	_delay_us(250);	
}

void ds18b20_write_byte(u16 pin, u8 data){     
	u8 i;    
	ds18b20_change_mode(pin, DS18B20_OUT);
	for(i=0; i<8; i++){ 	
		if(data&0x01){			
			GPIO_WriteBit(DS18B20_PORT, pin, 0);	
			GPIO_WriteBit(DS18B20_PORT, pin, 1);
			_delay_us(60);
		}
		else{
			GPIO_WriteBit(DS18B20_PORT, pin, 0);	
			_delay_us(60);
			GPIO_WriteBit(DS18B20_PORT, pin, 1);
		}			
		data>>=1;
		_delay_us(2);
	}  
}  

u8 ds18b20_read_byte(u16 pin){
	u8 i=0;
	u8 data=0;
	for(i=0; i<8; i++){		
		ds18b20_change_mode(pin, DS18B20_OUT);
		data>>=1;
		GPIO_WriteBit(DS18B20_PORT, pin, 0); 
		_delay_us(2);
		ds18b20_change_mode(pin, DS18B20_IN);
		if(GPIO_ReadInputDataBit(DS18B20_PORT, pin))  
			data|=0x80;
		_delay_us(60);   
	}
	ds18b20_change_mode(pin, DS18B20_OUT);
	return data; 
}  

void ds18b20_convert(u8 index){
	u16 pin=1<<index;
//	ds18b20_search_rom(pin);
	ds18b20_init(pin);
	ds18b20_write_byte(pin, 0xcc);
	ds18b20_write_byte(pin, 0x44);
	GPIO_WriteBit(DS18B20_PORT, pin, 1);
//	_delay_ms(375);
	ds18b20_change_mode(pin, DS18B20_IN);
}

u16 ds18b20_get_temp(u8 index){
	u16 rx_data;
	u8 low_byte,high_byte;
	u16 pin=1<<index;
	ds18b20_init(pin);
	ds18b20_write_byte(pin, 0xcc);
	ds18b20_write_byte(pin, 0xbe);
	low_byte=ds18b20_read_byte(pin);
	high_byte=ds18b20_read_byte(pin);
	rx_data=(high_byte<<8)|low_byte;	
	return rx_data;
}

/*
void ds18b20_search_rom(u16 pin){
	u8 i=0;
	u8 data[8];
	ds18b20_init(pin);
	ds18b20_write_byte(pin, 0x33);
	for(i=0; i<8; i++){
		data[i]=ds18b20_read_byte(pin);
		tft_prints(0,i,"%d   ", data[i]);
	}
	tft_update();
}

void ds18b20_config(void){
	ds18b20_init();
	ds18b20_write_byte(0xcc);
	ds18b20_write_byte(0x4e);
	ds18b20_write_byte(0x7f);
	ds18b20_write_byte(0xff);
	ds18b20_write_byte(0x7f);
	_delay_ms(700);
	
	ds18b20_init();
	ds18b20_write_byte(0xcc);
	ds18b20_write_byte(0x48);
	_delay_ms(300);
}
*/

int main(){
	if(ticks_img==0){

	if(get_seconds()%2){
	// motor_control(MOTOR0, 1000, 1);
	// motor_control(MOTOR1, 333, 0);
	// motor_control(MOTOR2, 500, 1);
	// motor_control(MOTOR3, 800, 0);
	for(index=0; index<8; index++){ 
	ds18b20_convert(index);
	}
	}
	else{
	mean_temp=0;
	for(index=0; index<4; index++){
	ds18b20_temp[index*2]=ds18b20_get_temp(index*2);
	tft_prints( 0 , index, "%d.%d ", (ds18b20_temp[index*2]>>4),(((ds18b20_temp[index*2]&0x000f)*1000)>>4));
	ds18b20_temp[index*2+1]=ds18b20_get_temp(index*2+1);
	tft_prints( 8 , index, "%d.%d ", (ds18b20_temp[index*2+1]>>4),(((ds18b20_temp[index*2+1]&0x000f)*1000)>>4));
	mean_temp+=ds18b20_temp[index*2]+ds18b20_temp[index*2+1];
	}
	mean_temp>>=3;
	}
	tft_prints( 0 , 7, "[%d.%d]", (mean_temp>>4),(((mean_temp&0x000f)*1000)>>4)); 
	tft_prints( 15 , 7, "%d", get_seconds()%10);
	tft_update(); 
	}
	
	return 0;
}
		
		

